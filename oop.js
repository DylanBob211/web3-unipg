/*
  **Esercizio 1: Counter**
  Implementare una classe `Counter` che accetta un valore iniziale `start` nel costruttore.
  Metodi: `increment()` aumenta il valore di 1, `decrement()` lo diminuisce di 1,
  `reset()` riporta il valore a `start`, `value()` restituisce il valore corrente.
*/

/*
  **Esercizio 2: Stack**
  Implementare una classe `Stack` (pila LIFO).
  Metodi: `push(item)` aggiunge un elemento in cima, `pop()` rimuove e restituisce l'elemento in cima
  (lancia un errore se lo stack è vuoto), `peek()` restituisce l'elemento in cima senza rimuoverlo,
  `isEmpty()` restituisce true se lo stack è vuoto.
  Proprietà: `size` restituisce il numero di elementi presenti.
*/

/*
  **Esercizio 3: BankAccount**
  Implementare una classe `BankAccount` con un campo privato `#balance`.
  Metodi: `deposit(amount)` aggiunge l'importo al saldo, `withdraw(amount)` sottrae l'importo
  (lancia un errore se il saldo è insufficiente), `getBalance()` restituisce il saldo corrente.
*/

/*
  **Esercizio 4: SavingsAccount**
  Implementare una classe `SavingsAccount` che estende `BankAccount`.
  Aggiungere il metodo `addInterest(rate)` che incrementa il saldo della percentuale indicata
  (es. `addInterest(0.05)` aggiunge il 5% al saldo corrente).
*/

/*
  **Esercizio 5: TodoList**
  Implementare una classe `TodoList` per gestire una lista di attività.
  Metodi: `add(text)` aggiunge un nuovo todo e restituisce il suo id generato automaticamente,
  `complete(id)` segna il todo con quell'id come completato,
  `remove(id)` rimuove il todo con quell'id,
  `getAll()` restituisce tutti i todo,
  `getPending()` restituisce solo i todo non ancora completati.
  Struttura interna libera — progettate voi come rappresentare ogni todo.
*/
